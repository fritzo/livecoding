TODO:
- Unit tests which demonstrate the frame reloading limitation.
- Unit tests which demonstrate the immutable method limitation.
- Pushing the overwriting approach to the limits.
- Starting an update in place approach.

----------------------------------------------------------------------

Title: Limiting factors in code reloading

<span style="font-weight:bold;">Local variables</span>

This will create a function which when run as a Stackless tasklet, blocks in mid-execution on a Stackless channel.<pre name="code" class="python">>>> import stackless
>>> c = stackless.channel()
>>> def f():
...     a = 1
...     b = {}
...     c.receive()</pre>Next the tasklet is created and run, leaving it blocked on the channel.<pre name="code" class="python">>>> t = stackless.tasklet(f)()
>>> t.run()</pre>The function in mid-execution has a frame encapsulating its running state, like the local variables within that executing function.  These variables can be accessed as a dictionary.  Sort of.<pre name="code" class="python">>>> dir(t)
[..., 'frame', ...]
>>> dir(t.frame)
[..., 'f_locals', ...]
>>> t.frame.f_locals
{'a': 1, 'b': {}}
>>> t.frame.f_locals['a'] = 2
>>> t.frame.f_locals
{'a': 1, 'b': {}}</pre>What this demonstrates is that there is no real local variable dictionary.  The one obtained above is actually constructed on request.

The repercussions of this are that code in mid-execution cannot be satisfactorily updated to reflect code reloading changes.  That code has to be able to continue executing without error using whatever objects it is holding onto, whatever the approach taken to code reloading is.

<span style="font-weight:bold;">Methods</span>

A method is a reference to a function, whether it is obtained from a class or an instance.  In the following case, a method is being obtained from a class.<pre name="code" class="python">>>> class X:
...     def f(self):
...             pass
...
>>> X.f
&lt;unbound method X.f&gt;</pre>Methods have attributes which refer to the class (<code>im_class</code>) and function involved (<code>im_func</code>), and possibly also an instance (<code>im_self</code>).  Bound methods are taken from instances and have values for all three attributes, whereas unbound methods are taken from classes and do not have an instance.  All of these attributes are read only and cannot be changed.<pre name="code" class="python">>>> dir(f)
[..., 'im_class', 'im_func', 'im_self']
>>> f.im_class
<class __main__.X at 0x01A1F720>
>>> f.im_class = X
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: readonly attribute</pre>

