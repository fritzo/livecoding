A moderately thorough exploration of code reloading within the Python runtime

==============================================================================
= WORKING NOTES: 20.03.2009

TODO LIST
- Implement the update approach.
- Unit test the arguments are updated.
- File change events.
  - Hook up the library from the old library.

==============================================================================
= WORKING NOTES: 19.03.2009

PRIORITIES
- Implement the update approach.
- File change events.
  - Hook up the library from the old library.

NOTES ON THE UPDATE APPROACH
- Algorithm:
  - Get the list of globals from the old script file.
  - Get the list of globals from the new script file.
  - Compile a mapping of attribute name to old value, new value.
    - No old value means None as first entry.
    - No new value means None as second entry.
  - Iterate over the mapping.
    - No new value.
      - Leaking old value.
      - NEXT ITERATION.
    - If the new value is not a class (does not subclass ClassType or TypeType).
      - If there is an old value and it is the same as the new value.
        - NEXT ITERATION.
      - If the new value is of type FunctionType.
        - Rebind it to the old locals.
      - If the new value is of type UnboundMethod or BoundMethod.
        - Rebind its 'im_func' to the old locals.
      - Set the new value of the attribute.
      - NEXT ITERATION.
    - New value must be a class.
      - Where there is no old class, no storing is needed.
      - Skip modules.
      - Skip classes where the module is '__builtin__'.
      - If there is an old value.
        - Identify all the attributes on the old class which are not on the new class.
        - Delete them from the old class.
        - NEXT ITERATION.
      - Iterate over the attributes on the new class.
        - If an attribute is of type FunctionType.
          - Rebind it to the old locals.
          - Store it on the old class.
        - If the attribute is of type UnboundMethod or BoundMethod.
          - Rebind its 'im_func' to the old locals.
          - Store it on the old class.
        - Otherwise.
          - Store the attribute on the old class.

TODO
- When script replacement compatibility checking is added:
  - Flesh out the checks in the leakage unit test.

==============================================================================
= WORKING NOTES: 17.03.2009

PRIORITIES
- Implement an update reload method.
  - The CodeReloadingObstacleTests test case ReloadScriptFile just calls ReloadScript on the code reloader.  This internally just does the overwrite method.
  - If I flesh out ReloadScript to do either method, then I might be able to duplicate the existing overwrite related tests and adapt them.
  - Renamed AddModuleAttributes in the namespace script directory handler to SetModuleAttributes.
  - Added a UpdateModuleAttributes to the reloader class.  This is really just reloading related and belongs there, rather than in the namespacing class.
    - Copy SetModuleAttributes and change it.
    - Need to write a whole class and function updating thing.
- File change events.
  - Hook up the library from the old library?

TODO
- When script replacement compatibility checking is added:
  - Flesh out the checks in the leakage unit test.
- When UpdateModuleAttributes is working
  - Remove attribute filtering duplication between it and SetModuleAttributes.

==============================================================================
= WORKING NOTES: 13.03.2009

TODO
- When script replacement compatibility checking is added:
  - Flesh out the checks in the leakage unit test.

ATTRIBUTE LEAKING
- Refactored code reloading module to separate script reloading functionality.
- Wrote leakage unit test.
- Refactored attribute leakage into the code reloading module from the script class.

==============================================================================
= WORKING NOTES: 12.03.2009

NOTES ON LEAKING DELETED ENTRIES FROM YESTERDAY
- Have an index of what was leaked, and what leaked it.
- Allow compatible replacements from the same source file.
- Disallow replacements from other source files.

ADDING SUPPORT FOR LEAKING DELETED ENTRIES
- Started writing overwrite support.
  - This is not what I was supposed to be doing.  But it needs to be done in order to add leaking support.  The problem is that adding it to the namespacing solution is not what I should be doing.  I should be adding it to the code reloading solution.
- Fleshing out the reloading module should drive changes to the namespace module.
  - Implementing a ReloadScript method.
    - Keep focus.  Stick to overwriting reloads, with leakage for now.
      - Load in the new version of the script file.
      - Note what attributes the old script file contributes.
      - Insert the attributes from the new script file, allowing overwriting of entries contributed by the old script file.
      - Keep track of the contributions of the old script file, which were not overwritten.
      - Note them down for future handling.
        - This will do for now.  Just leak them.
      - No, it won't do.  I also need to propagate them down further versions of the file.
        - If a new file
    - Future handling jottings for later contemplation.
      - Add them into the new script file's globals.
        - Record what version of the script file they came from and what their variable name is in an inherited attributes dataset.
- Added.
  - Leaking propagates through further versions of a script file, through reloads.
  - Replacement of removed attribute, will result in the leak being removed.

POSSIBLE TASKS FOR TOMORROW:
- Unit test leaking.
  - Attribute is removed from a new version of the script file.
    - Attribute appears in the leaked attributes dictionary of the new script file.
    - Attribute is still present in the namespace.
  - Attribute was already leaked, and reload comes with no replacement.
    - New script file has leak entry propagated from old script file.
    - Attribute is still present in the namespace.
  - Attribute was already leaked, and reload comes with an invalid replacement.
    - Reload is rejected.
  - Attribute was already leaked, and reload comes with a valid replacement.
    - New script file lacks leak entry for attribute.
    - Attribute in namespace is value from new script file.

FINAL THOUGHTS:
- While writing the attribute leakage unit test outline, it occurred to me to consider storing leaked attribute information on the namespace itself.
  - namespace.__leaked_attributes__[attributeName] = [ filePath, fileVersion ]
  - What if another file contributed a compatible replacement?
  - This might be the programmer refactoring and moving entries between files.

==============================================================================
= WORKING NOTES: 11.03.2009

Namespace loader does:
- Directory loading:
  - Locates each script file and load it.
- Dependency resolution loop, each script is run:
  - Namespace entry made/retrieved.
  - Module attributes from the script are injected.

THINKING THINGS THROUGH
- Tracking contributed attributes.
  - In the overwrite case, I have it so that ...
  - Actually, what happens when a file is updated using overwriting.
    - If there are items which were present in the namespace, which are no longer in the class, should they be removed?  Any running code using indirect referencing, will error when they next try.
      - Possible indirect referenced attribute types:
        - Classes.
        - Constants.
      - Having to keep these around while they are still in use doesn't mean they have to be kept around for the life of the application.
        - If I track the removed entries, then maybe I can check their referrers periodically to determine if they are still in use.
    - Replacement with incompatible entries should result in a rejected reload.
      - File is loaded and provides game.Value as a class.
      - File is reloaded and no longer has Value.
      - File is reloaded and Value is back as an integer.
        - Reject the reload.

DECISION ON INTELLIGENTLY KEEPING ONLY USED STALE ENTRIES: DEFERRED
- Working out what is holding references to namespace entries which are being
  removed on the updating of a script file, is proving too much effort and is
  wasting valuable attention span and time.
  - Need to give up on it for now.  What approach do I take, if I don't do it?
    - Can only leave disowned entries in place to ensure reliability.
    - Keep track of who originally contributed them.
      - Error if they are recontributed by someone else.
      - Attempt an override if they are reinstated by the original contributor.
        - But do compatibility check.

APPROACH TO LEAKING ALL CONTRIBUTED ENTRIES
- Have an index of what was leaked, and what leaked it.
- Allow compatible replacements from the same source file.
- Disallow replacements from other source files.

==============================================================================
= RESOLUTIONS:

What reloading approaches should be supported?
- Overwriting, updating or both.

What about the indirect namespacing to entries which were deleted from updated modules?
- Deleted entries need to be left in place as long as they are in use.

==============================================================================
= TODO:

WHITE PAPER:

- Pushing the overwriting approach to the limits.
  - Base class replacement. DONE.
  - Global variable replacement. DONE.
  - Combination of both. DONE.
  - Document for future reference. DONE.
- Unit test which demonstrates the local variable modification limitation. DONE.
- Unit tests which demonstrate the frame reloading limitation. DONE.
- Unit tests which demonstrate the immutable method limitation. DONE.

- Starting an update in place approach.
  - Single file update test.
    - Need a reload method which does update in place.
      The current code 'ReloadScriptFile' does the overwrite.
      No internals are currently exposed from the modules to allow update in place.
  - Different file base class update test.

- Comparison of the pros and cons of both approaches.

- Analysis of the limitations of 'reload'.

FUNCTIONALITY:

- Classes
  - Doc strings are updated.
  - Function are updated.
    - Doc strings are updated.
    - Arguments on functions are updated.
  - Slots.
  - Properties.
  - Class methods / static methods.
