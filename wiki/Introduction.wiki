#summary One-sentence summary of this page.
#labels Featured

= Live coding in Python =

This library is licensed under the BSD license, which is distributed with
it and can be found in the same directory as the file 'LICENSE'.

== Authors / Contact information ==

 * Michael Brannan
 * Richard Tew <richard.m.tew@gmail.com>

== Introduction ==

This library provides live coding support.

Directories containing Python scripts can be registered to be monitored
so that any time a change is made to a script the code within it will be
reloaded and put in place transparently.

Note that these directories should not be those of standard Python
modules available for normal import.  The reason for this is that this
library manually processes the contents of registered directories and
places them so that they can be imported.  By handling this itself,
this allows the library to know enough to apply changes to modules
as they happen.

Yes, this means that the directories registered must follow a custom
structure.  An arbitrary one determined by my fellow authors and I
after several years of using another arbitrary one at CCPGames.

== Custom importing ==

The custom importing works in a straightforward manner.  When you register a
directory with this library, the contents of that directory are directly
mapped to the import namespace.

These examples should illustrate how this works in practice.

=== Example 1: One file in a subdirectory ===

'''Note:''' Modules become available for importing through directory contents
being registered with this library.  And how the contents of those directories
are made available for importing differs from the standard Python module way.

Let's say you have a directory 'stuff' and the following subdirectory and
file are in there:

{{{
  stuff/services/net.py
}}}

And net.py has the following class defined inside it:

{{{
  NetService
}}}

You might register the contents of the 'stuff' directory under the base
namespace 'server' in this manner:

{{{
  import livecoding
  livecoding.AddDirectory("stuff", "server")
}}}
  
Now this will result in a 'services' submodule for 'server' and the contents
of the Python scripts in the corresponding 'services' directory will be placed
in this submodule.

Then it is now possible to do the following:

{{{
  import server
  from server import services
  from server.services import NetService
}}}

=== Example 2: Two files in a subdirectory ===

'''Note:''' Modules directly map to directory structure which means that the
contents of all python scripts within a given directory are placed in the
module for that directory.

Let's say you have a directory 'stuff' and the following subdirectory and
files are in there:

{{{
  stuff/services/net.py
  stuff/services/data.py
}}}

And net.py has the following class defined inside it:

{{{
  NetService
}}}

And data.py has the following class defined inside it:

{{{
  DataService
}}}

Now registering the directory in the same manner as the first example, it
is possible to do the following: 

{{{
  import server
  from server import services
  from server.services import NetService
  from server.services import DataService
}}}

=== Example 3: Directory contents can be merged into a namespace ===

'''Note:''' By registering two directories under the same base namespace
the contents get merged into the corresponding modules which are created.

Let's say you have a directory 'stuff1' and the following subdirectory and
file are in there:

{{{
  stuff1/services/net.py
}}}

But you also have a directory 'stuff2' with a matching subdirectory and
a different file:

{{{
  stuff2/services/data.py
}}}

These files provide the same classes as in the previous example.  Next both
'stuff1' and 'stuff2' are registered under the same base namespace:

{{{
  import livecoding
  livecoding.AddDirectory("stuff1", "server")
  livecoding.AddDirectory("stuff2", "server")
}}}

And it is still possible to do the following:

{{{
  from server.services import NetService
  from server.services import DataService
}}}

== Potential problems ==

 * If someone were to add a directory under a standard library namespace
   then it might merge the contents of the directory into that existing
   namespace.  But is it really practical to prevent it given that it can
   work the other way round - where the standard library module might be
   inaccessible because the one provided through this library was imported
   first.

== Todo ==

 * Some code to detect changed files.